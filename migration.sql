-- Create a simple user profile table if it doesn't exist.
-- This is a common pattern and is referenced by the user_files table.
CREATE TABLE IF NOT EXISTS public.user_bio (
  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username TEXT UNIQUE,
  full_name TEXT
);

-- Create the table to track file uploads
CREATE TABLE IF NOT EXISTS public.user_files (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  -- Use UUID to reference the user from the auth schema
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  -- Use an ENUM type for file_type for better data integrity
  file_type TEXT NOT NULL CHECK (file_type IN ('resume', 'transcript', 'project')),
  file_name TEXT NOT NULL,
  bucket_name TEXT NOT NULL,
  -- The path within the bucket
  file_path TEXT NOT NULL UNIQUE,
  CONSTRAINT user_files_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users (id)
);

-- Enable Row-Level Security (RLS) for the user_files table
ALTER TABLE public.user_files ENABLE ROW LEVEL SECURITY;

-- Create policies for storage access.
-- This is how you grant permissions to buckets.

-- Policy: Allow public read access to all files
CREATE POLICY "Allow public read access" ON storage.objects
FOR SELECT USING (true);

-- Policy: Allow authenticated users to upload files
CREATE POLICY "Allow authenticated uploads" ON storage.objects
FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- Policy: Allow users to update their own files
CREATE POLICY "Allow user to update their own files" ON storage.objects
FOR UPDATE USING (auth.uid() = owner);

-- Policy: Allow users to delete their own files
CREATE POLICY "Allow user to delete their own files" ON storage.objects
FOR DELETE USING (auth.uid() = owner);
